## HEAD OF ENGINEERING: Haven Review

### Executive Summary (3 sentences max)
Haven is an impressively well-structured vanilla JS game with clean module boundaries, a solid event-driven architecture, and a procedural audio system that rivals professional game engines -- all without a single external dependency. The biggest strength is the IIFE module pattern with event-bus communication: 20 modules talk through Game.on/emit rather than direct coupling, making the codebase far more maintainable than most prototype-stage games. The biggest risk is the combined weight of no build system, no tests, mixed ES5/ES6 syntax, string-concatenated HTML rendering, and a single-key localStorage save system with no versioning or corruption recovery -- these are manageable at prototype scale but will compound into serious technical debt at production scale.

### Dimension Scores
| Dimension | Score | Evidence |
|-----------|-------|----------|
| Code architecture & maintainability | 3.5/5 | 20 modules all use IIFE or arrow-IIFE pattern returning public APIs (e.g., `var Board = (function() { ... })()` at board.js:1, `const Sound = (() => { ... })()` at audio.js:4, `var Island = (function() { ... })()` at island.js:4). Modules communicate via event bus: Game.on/emit with events like 'mergeCompleted', 'itemSpawned', 'creatureDiscovered', 'powerupUsed' (game.js:44-89 for the event system). This is clean separation. However, there is **inconsistent ES version**: Board, Tutorial, PowerUps, Island, Daily use `var` + `function()` (ES5 style), while Sound, Particles, Combo, Recipes use `const` + `() =>` (ES6). Both styles coexist in the same codebase with no transpiler. Named constants are good (SURGE_PER_MERGE=35, CLUTTER_THRESHOLD=8, MIN_MERGE=3 in board.js:15-32), but some magic numbers remain inline (e.g., `0.04` critical merge chance at board.js:825, `12` pity threshold at board.js:27). Script loading order is hardcoded in index.html:384-420 with 20 script tags -- order matters, and there's no dependency management. |
| Performance (render efficiency, memory, events) | 3/5 | **Good:** Board grid uses cached coordinate lookup via `getCellFromCoords()` (board.js:87-100) with `getBoundingClientRect()` on the board once, then math-based cell resolution -- avoids expensive `elementFromPoint`. Per-cell locking (board.js:584-587) replaces a global `animating` flag, allowing concurrent animations on non-adjacent cells. Canvas particle system (particles.js) uses `requestAnimationFrame` with proper delta-time capping at 50ms (particles.js:122). Surge decay timer uses `setInterval(100ms)` with cleanup on reaching zero (board.js:638-653). **Concerning:** `particles.splice(i, 1)` inside a reverse loop (particles.js:131) is O(n) per removal, O(n^2) worst case for a burst of 50 particles -- should use swap-and-pop. `renderCell()` (board.js:1280-1328) does full `cell.innerHTML = ''` DOM rebuild on every update -- no diffing or reuse. `highlightTargets()` (board.js:469-481) iterates all 48 cells on every tap/drag-start. `clearHighlight()` uses `querySelectorAll` (board.js:483-488). Shop (shop.js:289-441) and Island (island.js:234-398) rebuild their entire UI via `container.innerHTML = html` on every render. For a 48-cell board these are acceptable, but they set a pattern that won't scale. No `will-change` usage on frequently animated elements except 4 selectors noted in Art/UX review. |
| Save system robustness | 2/5 | Single localStorage key stores ALL game state as one JSON blob (game.js:24-42, `save()` writes `JSON.stringify(state)`, `load()` reads and parses). `Game.save()` is called on nearly every action: every merge (board.js syncToGameState), every spawn, every shop purchase, every achievement update, every island unlock. No save debouncing -- on a fast merge streak, `save()` could fire 10+ times per second. No schema versioning (only Island has a legacy migration at island.js:131-150). No corruption detection -- if `JSON.parse` fails, load silently returns empty state (game.js:37-40 has try/catch that falls through). No backup save, no cloud sync, no export/import. localStorage has a ~5MB limit; current state is small but creature collection + board + achievements + discovered items will grow. No save-state validation (e.g., negative gems, impossible tier values). |
| Error handling & edge cases | 2.5/5 | **Good edge case handling in Board:** energy refund on board-full (board.js:1129), free shuffle when no merges possible (board.js:1146-1153), cell locking prevents animation race conditions (board.js:584-587), pointer cancel handler cleans up drag state (board.js:351-369), single-pointer locking prevents multi-touch chaos (board.js:152-154). Tutorial gracefully skips missing targets (tutorial.js:312-315). **Weak:** Only one try/catch in the entire codebase (audio.js:12-29). No error boundaries -- if any module's init() throws, subsequent modules in the loading chain may fail silently. `confirm()` used for IAP simulation (shop.js:188, 205, 225) -- blocking, non-standard, and will break on any platform that doesn't support it. Island `skipNode()` (island.js:202-229) deducts 50 gems then adds node reward gems -- if the node reward is >50 gems, skip is profitable (design bug, but also an unchecked edge case). No input sanitization on any user-facing text, though currently no user text input exists. Events.hasModifier/getModifierValue are defined (events.js:304-315) but never called from board.js or game.js -- **event modifiers are dead code** (confirmed by searching the codebase). |
| Scalability & extensibility | 3/5 | **Good extensibility patterns:** Event bus decouples modules cleanly -- adding a new system (e.g., guilds, PvP) only requires listening to existing events. Items.js chain/tier structure supports adding new chains by extending the chains object (items.js:5-148). Power-up system uses a definition table + earnEvent pattern (powerups.js:6-55) -- adding a new power-up is just adding a definition. Achievement system supports back-fill from stats (achievements.js:167-268). **Scalability limits:** All content is hardcoded in JS arrays: 8 events (events.js:11-139), 12 daily quests (daily.js:17-30), 50 achievements (achievements.js:8-98), 40 pass tiers (pass.js:18-53), 184 creatures (creatures.js:24-240). No JSON/YAML config files, no CMS, no server-side anything. Board is fixed 8x6 with constants ROWS=8, COLS=6 (board.js:2-3). No board expansion mechanic. Shop HTML is hardcoded string concatenation (shop.js:289-441) -- adding a new section requires editing a 150-line render function. No build system means no minification, no tree-shaking, no code splitting -- all 20 scripts load on every page load. No TypeScript, no JSDoc, no automated tests of any kind. |

### Critical Findings

1. **[BLOCKER] Event modifiers are defined but never wired into gameplay -- dead code**
   - Evidence: Events.hasModifier() and Events.getModifierValue() are exported (events.js:304-315). Crystal Rush defines `{ type: 'gem_multiplier', chain: 'crystal', value: 2 }` (events.js:19), Speed Demon defines `{ type: 'energy_regen_multiplier', value: 2 }` (events.js:130), Merge Mania defines `{ type: 'min_merge_override', value: 2 }` (events.js:98). However: board.js never calls Events.hasModifier or Events.getModifierValue anywhere. Neither does game.js. The gem reward calculation (board.js:888-918) has no event modifier branch. The spawn function (board.js:1084-1232) has no tier-boost check. The energy regen timer (game.js:107-141) has no multiplier check. Event challenge TRACKING works (events.js:246-268), but the advertised gameplay modifiers are lies.
   - Impact: This is not just a game design issue -- it's dead code that will confuse any engineer who reads it. The API exists, the data exists, but nothing connects them. This is the kind of disconnected code that causes maintenance nightmares: someone will assume it works and build on top of it, or someone will delete it thinking it's unused.
   - Recommendation: Wire the modifier checks into 4 specific locations: (1) board.js:888 gem reward calculation -- check `Events.getModifierValue('gem_multiplier', chain)`, (2) board.js:1166 spawn tier -- check `Events.getModifierValue('spawn_tier_boost', chain)`, (3) board.js:706 MIN_MERGE override -- check `Events.getModifierValue('min_merge_override')`, (4) game.js:109 energy regen interval -- check `Events.getModifierValue('energy_regen_multiplier')`. Estimated effort: 2-4 hours with testing.

2. **[RISK] Save system has no debouncing, no versioning, no corruption recovery**
   - Evidence: `Game.save()` (game.js:24-30) calls `localStorage.setItem('havenState', JSON.stringify(state))` directly. It is called from: board.js `syncToGameState()` after every merge/spawn/move, shop.js `saveShopState()` on every piggy bank increment (every merge!), powerups.js `saveState()` on every earn-progress tick, island.js `saveIslandState()`, daily.js, pass.js, events.js, achievements.js, welcome.js, recipes.js. During active play, save() fires 3-5 times per second minimum. `load()` (game.js:32-42) has a try/catch but on parse failure returns `{}` with no recovery attempt. No save format version number. No backup rotation.
   - Impact: On low-end Android devices (the primary casual game demographic), synchronous localStorage writes at 3-5 Hz will cause frame hitches. If localStorage corrupts (browser crash, storage full, Private Browsing), all player progress is permanently lost with no recovery path. As features are added and state shape changes, there's no migration mechanism to update old saves.
   - Recommendation: (1) Debounce saves with a 500ms dirty-flag timer -- mark state dirty on change, write once per 500ms. (2) Add a `saveVersion: 1` field to state with a migration function on load. (3) Keep a `havenState_backup` key updated every 60 seconds -- on primary parse failure, try the backup. (4) Add `havenState_lastGood` that only updates after validated successful saves. Estimated effort: half day.

3. **[RISK] Mixed ES5/ES6 syntax with no transpiler creates compatibility fragility**
   - Evidence: ES6 features in use: `const` + arrow functions (Sound, Particles, Combo, Recipes, Shop), template literals (none found -- string concat used throughout), `let` (particles.js, combo.js), `Array.forEach` with arrow callbacks (board.js:1258, shop.js:353,366), destructuring (none). ES5 patterns: `var` everywhere in Board, Tutorial, PowerUps, Island, Daily, Pass, Events, Achievements, Orders, Welcome, Creatures, Hatchery. `function()` expressions in most modules. No Babel, no polyfills, no build step. The `<script>` tags load raw JS files (index.html:384-420).
   - Impact: All modern mobile browsers support ES6, so this works TODAY. But: (1) inconsistent style makes the codebase harder to read and maintain, (2) adding any ES2020+ features (optional chaining, nullish coalescing) would require a build step, (3) no source maps for debugging in production. The lack of a build step also means no minification -- 20 JS files totaling ~8000 lines load as-is, with no compression, concatenation, or tree-shaking.
   - Recommendation: Add a minimal build step: either (a) a single esbuild/Vite config that bundles + minifies (15 minutes to set up), or (b) standardize on ES6 throughout and add a polyfill for any edge cases. MEDIUM priority -- not blocking for prototype, but blocking for production. Estimated effort: 2-4 hours for build tooling.

4. **[RISK] HTML rendering via innerHTML string concatenation is fragile and unmaintainable**
   - Evidence: Shop render (shop.js:289-441) builds 150+ lines of HTML as string concatenation, then sets `container.innerHTML = html`. Island roadmap (island.js:234-398) similarly builds the entire map via createElement + innerHTML. Achievements panel (achievements.js:370-500+) does the same. All event listeners are attached AFTER innerHTML assignment using querySelectorAll loops (shop.js:418-441, island.js:363-376). Every render completely destroys and rebuilds the DOM subtree.
   - Impact: (1) Adding any feature to these screens requires editing deeply nested string concatenation -- high bug risk. (2) Full innerHTML rebuilds destroy scroll position, focus state, and animation state. (3) Event listener re-attachment on every render creates potential for listener leaks if old references aren't properly cleaned (the current code does replace innerHTML which removes old listeners, but any external references would leak). (4) No XSS risk currently since there's no user-generated content, but the pattern is inherently unsafe if user text is ever displayed.
   - Recommendation: For the prototype, this is livable. For production, consider: (a) a lightweight template system (e.g., lit-html or simple diffing helper), or (b) at minimum, extract repetitive HTML builders into helper functions that return DocumentFragments. Do NOT rewrite to React/Vue -- the vanilla JS architecture is actually a strength for performance. Estimated effort: 1-2 days for helper extraction.

5. **[OPPORTUNITY] The event bus architecture is production-quality -- protect and extend it**
   - Evidence: Game.on/emit/off (game.js:44-89) implements a clean pub/sub pattern. Events are well-named and semantic: 'mergeCompleted', 'itemSpawned', 'creatureDiscovered', 'surgeActivated', 'orderCompleted', 'crossChainMerge', 'powerupUsed', 'energyEmpty', 'starsChanged'. Modules subscribe during init() and emit during their operations. Tutorial cleanup properly unregisters handlers (tutorial.js:543-549). This decoupling is why 20 modules coexist without spaghetti imports.
   - Impact: This architecture makes it trivial to add new systems: analytics (listen to all events), A/B testing (intercept events), server sync (batch events and send), replay recording (log events). It's the right foundation.
   - Recommendation: Add an `Game.emitAll()` or event logging mode that records all emitted events with timestamps to a buffer. This enables: (1) session replay for debugging, (2) analytics pipeline, (3) server-side event validation. Also consider adding typed event payloads (even just as JSDoc comments) so new developers know what data each event carries. LOW effort, HIGH long-term value.

6. **[OPPORTUNITY] Per-cell locking is an elegant solution to animation race conditions**
   - Evidence: `lockCell(r, c)` / `unlockCell(r, c)` / `isCellLocked(r, c)` (board.js:584-587) use a simple object hash. findConnected() respects locks (board.js:749), preventing mid-animation cells from being included in new merge calculations. executeMerge() locks all involved cells before starting animations (board.js:775-776) and unlocks them in the setTimeout callback after animation completes. This replaces a global `isAnimating` flag that would block all interactions during any animation.
   - Impact: This pattern enables the fluid, responsive feel where players can queue merges while previous animations are still playing. It's a significant contributor to the "juice" factor.
   - Recommendation: Document this pattern prominently. Any engineer adding new board interactions MUST use lock/unlock or they'll create race conditions. Consider adding a `lockRegion(cells)` / `unlockRegion(cells)` helper that takes an array, since executeMerge already uses this pattern via forEach. LOW effort.

7. **[RISK] Particle system splice-in-loop is O(n^2) for large bursts**
   - Evidence: particles.js:127-133 iterates `particles` array in reverse, calling `particles.splice(i, 1)` for each dead particle. Array.splice is O(n) per call (shifts all subsequent elements). A legendary particle burst emits 50 particles (particles.js:100-114). In the worst case (all 50 dying on the same frame), this is 50 splice operations on a shrinking array: ~50+49+48+... = O(n^2).
   - Impact: For 50 particles, this is ~1250 array operations per frame -- negligible. But if particle counts increase (e.g., screen-wide celebration effects with 200+ particles), frame drops will occur. The pattern also prevents V8 from optimizing the array to a contiguous buffer.
   - Recommendation: Use swap-and-pop: instead of `splice(i, 1)`, swap dead particles to the end and truncate the array length once. This makes removal O(1) per particle, O(n) total. Estimated effort: 30 minutes.

8. **[RISK] No automated tests of any kind**
   - Evidence: No test files exist in the project. No test framework referenced. No CI/CD configuration. The codebase has zero test coverage.
   - Impact: Every change requires manual playtesting to verify. The merge logic (findConnected, executeMerge, chain reactions), gem reward calculations, energy management, save/load, and creature discovery are all complex systems with edge cases that should have regression tests. The event modifier bug (Finding #1) would have been caught by a single integration test.
   - Recommendation: Add a minimal test harness for the pure-logic modules: Items.canMerge, Items.getCrossChainResult, findConnected (extract to testable function), gem reward calculation, energy management, creature discovery probability. Use a zero-config test runner like Vitest or even a simple HTML page that runs assertions. Focus on the merge hot path first. Estimated effort: 1-2 days for initial test suite.

### Trade-off Flags
- **vs. Game Design:** The save debouncing recommendation (Finding #2) means state won't persist instantly -- a browser crash within 500ms of a merge loses that merge. Game Design may prefer immediate persistence. Compromise: debounce to 200ms and add a `beforeunload` handler that forces a final save.
- **vs. Art/UX:** The innerHTML recommendation (Finding #4) could affect the Art team's ability to iterate on UI styling if the rendering approach changes. Any refactoring must maintain the exact same DOM structure and CSS class names.
- **vs. Live Ops:** The content hardcoding issue (multiple findings) is shared between Engineering and Live Ops. Engineering will need to build the config-driven content system that Live Ops requires. This should be a joint priority.
- **vs. Monetization:** Adding ad SDK integration (Monetization's Finding #3) will require Engineering to add the first external dependency and handle async loading, which conflicts with the current zero-dependency architecture. Suggest an ad adapter module that isolates the SDK behind Haven's event bus.

### Go/No-Go Signal
**AMBER** -- The codebase is remarkably clean for a prototype, with a production-quality event architecture and smart performance choices (per-cell locking, cached grid lookup, canvas particles). However, the dead event-modifier code is a trust-breaking bug that must be fixed, the save system needs hardening before any real users touch it, and the complete absence of tests makes every change risky. Fix the event wiring, add save debouncing + backup, and add basic merge-logic tests before soft launch. The vanilla JS architecture is a strength, not a weakness -- do not rewrite to a framework.
